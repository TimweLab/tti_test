// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RxGesture
import Foundation
import ObjectiveC
import RxCocoa
@_exported import RxGesture
import RxSwift
import Swift
import UIKit.UIGestureRecognizerSubclass
import UIKit
import _Concurrency
@objc @_inheritsConvenienceInitializers @available(iOS 9.0, *)
@_Concurrency.MainActor(unsafe) public class ForceTouchGestureRecognizer : UIKit.UIGestureRecognizer {
  @_Concurrency.MainActor(unsafe) public var numberOfTouchesRequired: Swift.Int
  @_Concurrency.MainActor(unsafe) public var force: CoreGraphics.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public var maximumPossibleForce: CoreGraphics.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public var fractionCompleted: CoreGraphics.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @objc deinit
}
@available(iOS 9.0, *)
public typealias ForceTouchConfiguration = RxGesture.Configuration<RxGesture.ForceTouchGestureRecognizer>
@available(iOS 9.0, *)
public typealias ForceTouchControlEvent = RxCocoa.ControlEvent<RxGesture.ForceTouchGestureRecognizer>
@available(iOS 9.0, *)
public typealias ForceTouchObservable = RxSwift.Observable<RxGesture.ForceTouchGestureRecognizer>
@available(iOS 9.0, *)
extension RxGesture.Factory where Gesture == RxGesture.GestureRecognizer {
  public static func forceTouch(configuration: RxGesture.ForceTouchConfiguration? = nil) -> RxGesture.AnyFactory
}
@available(iOS 9.0, *)
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func forceTouchGesture(configuration: RxGesture.ForceTouchConfiguration? = nil) -> RxGesture.ForceTouchControlEvent
}
@available(iOS 9.0, *)
extension RxSwift.ObservableType where Self.E : RxGesture.ForceTouchGestureRecognizer {
  public func asForce() -> RxSwift.Observable<CoreGraphics.CGFloat>
}
public typealias Configuration<Gesture> = (Gesture, RxGesture.RxGestureRecognizerDelegate) -> Swift.Void
public struct Factory<Gesture> where Gesture : UIKit.UIGestureRecognizer {
  public let gesture: Gesture
  public init(_ configuration: RxGesture.Configuration<Gesture>?)
}
public typealias AnyFactory = RxGesture.Factory<RxGesture.GestureRecognizer>
extension RxSwift.ObservableType where Self.E : UIKit.UIGestureRecognizer {
  public func when(_ states: RxGesture.GestureRecognizerState...) -> RxSwift.Observable<Self.E>
  public func asLocation(in view: RxGesture.TargetView = .view) -> RxSwift.Observable<RxGesture.Point>
}
public struct GestureRecognizerDelegatePolicy<PolicyInput> {
  public typealias PolicyBody = (PolicyInput) -> Swift.Bool
  public static func custom(_ policy: @escaping RxGesture.GestureRecognizerDelegatePolicy<PolicyInput>.PolicyBody) -> RxGesture.GestureRecognizerDelegatePolicy<PolicyInput>
  public static var always: RxGesture.GestureRecognizerDelegatePolicy<PolicyInput> {
    get
  }
  public static var never: RxGesture.GestureRecognizerDelegatePolicy<PolicyInput> {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class RxGestureRecognizerDelegate : ObjectiveC.NSObject, RxGesture.GestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) final public var beginPolicy: RxGesture.GestureRecognizerDelegatePolicy<RxGesture.GestureRecognizer>
  @_Concurrency.MainActor(unsafe) final public var touchReceptionPolicy: RxGesture.GestureRecognizerDelegatePolicy<(RxGesture.GestureRecognizer, RxGesture.Touch)>
  @_Concurrency.MainActor(unsafe) final public var selfFailureRequirementPolicy: RxGesture.GestureRecognizerDelegatePolicy<(RxGesture.GestureRecognizer, RxGesture.GestureRecognizer)>
  @_Concurrency.MainActor(unsafe) final public var otherFailureRequirementPolicy: RxGesture.GestureRecognizerDelegatePolicy<(RxGesture.GestureRecognizer, RxGesture.GestureRecognizer)>
  @_Concurrency.MainActor(unsafe) final public var simultaneousRecognitionPolicy: RxGesture.GestureRecognizerDelegatePolicy<(RxGesture.GestureRecognizer, RxGesture.GestureRecognizer)>
  @available(iOS 9.0, *)
  @_Concurrency.MainActor(unsafe) final public var pressReceptionPolicy: RxGesture.GestureRecognizerDelegatePolicy<(RxGesture.GestureRecognizer, UIKit.UIPress)> {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizerShouldBegin(_ gestureRecognizer: RxGesture.GestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: RxGesture.GestureRecognizer, shouldReceive touch: RxGesture.Touch) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: RxGesture.GestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: RxGesture.GestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: RxGesture.GestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: RxGesture.GestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: RxGesture.GestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: RxGesture.GestureRecognizer) -> Swift.Bool
  @available(iOS 9.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive press: UIKit.UIPress) -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public typealias Touch = UIKit.UITouch
public typealias GestureRecognizer = UIKit.UIGestureRecognizer
public typealias GestureRecognizerState = UIKit.UIGestureRecognizer.State
public typealias GestureRecognizerDelegate = UIKit.UIGestureRecognizerDelegate
public typealias View = UIKit.UIView
public typealias Point = CoreGraphics.CGPoint
public enum TargetView {
  case view
  case superview
  case window
  case this(RxGesture.View)
  public func targetView(for gestureRecognizer: RxGesture.GestureRecognizer) -> RxGesture.View?
}
extension UIKit.UIGestureRecognizer.State : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class TouchDownGestureRecognizer : UIKit.UILongPressGestureRecognizer {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @_Concurrency.MainActor(unsafe) public var isTouchIgnoringEnabled: Swift.Bool
  @nonobjc @_Concurrency.MainActor(unsafe) public var touches: Swift.Set<UIKit.UITouch>
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func reset()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func ignore(_ touch: UIKit.UITouch, for event: UIKit.UIEvent)
  @objc deinit
}
public typealias TouchDownConfiguration = RxGesture.Configuration<RxGesture.TouchDownGestureRecognizer>
public typealias TouchDownControlEvent = RxCocoa.ControlEvent<RxGesture.TouchDownGestureRecognizer>
public typealias TouchDownObservable = RxSwift.Observable<RxGesture.TouchDownGestureRecognizer>
extension RxGesture.Factory where Gesture == RxGesture.GestureRecognizer {
  public static func touchDown(configuration: RxGesture.TouchDownConfiguration? = nil) -> RxGesture.AnyFactory
}
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func touchDownGesture(configuration: RxGesture.TouchDownConfiguration? = nil) -> RxGesture.TouchDownControlEvent
}
extension RxSwift.ObservableType where Self.E : RxGesture.TouchDownGestureRecognizer {
  public func asTouches() -> RxSwift.Observable<Swift.Set<UIKit.UITouch>>
}
public struct TransformGestureRecognizers {
  public let panGesture: UIKit.UIPanGestureRecognizer
  public let rotationGesture: UIKit.UIRotationGestureRecognizer
  public let pinchGesture: UIKit.UIPinchGestureRecognizer
}
public struct TransformVelocity {
}
public typealias TransformConfiguration = RxGesture.Configuration<RxGesture.TransformGestureRecognizers>
public typealias TransformControlEvent = RxCocoa.ControlEvent<RxGesture.TransformGestureRecognizers>
public typealias TransformObservable = RxSwift.Observable<RxGesture.TransformGestureRecognizers>
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func transformGestures(configuration: RxGesture.TransformConfiguration? = nil) -> RxGesture.TransformControlEvent
}
extension RxSwift.ObservableType where Self.E == RxGesture.TransformGestureRecognizers {
  public func when(_ states: RxGesture.GestureRecognizerState...) -> RxSwift.Observable<Self.E>
  public func asTransform(in view: RxGesture.TargetView = .view) -> RxSwift.Observable<(transform: CoreGraphics.CGAffineTransform, velocity: RxGesture.TransformVelocity)>
}
public typealias LongPressConfiguration = RxGesture.Configuration<UIKit.UILongPressGestureRecognizer>
public typealias LongPressControlEvent = RxCocoa.ControlEvent<UIKit.UILongPressGestureRecognizer>
public typealias LongPressObservable = RxSwift.Observable<UIKit.UILongPressGestureRecognizer>
extension RxGesture.Factory where Gesture == RxGesture.GestureRecognizer {
  public static func longPress(configuration: RxGesture.LongPressConfiguration? = nil) -> RxGesture.AnyFactory
}
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func longPressGesture(configuration: RxGesture.LongPressConfiguration? = nil) -> RxGesture.LongPressControlEvent
}
public typealias PanConfiguration = RxGesture.Configuration<UIKit.UIPanGestureRecognizer>
public typealias PanControlEvent = RxCocoa.ControlEvent<UIKit.UIPanGestureRecognizer>
public typealias PanObservable = RxSwift.Observable<UIKit.UIPanGestureRecognizer>
extension RxGesture.Factory where Gesture == RxGesture.GestureRecognizer {
  public static func pan(configuration: RxGesture.PanConfiguration? = nil) -> RxGesture.AnyFactory
}
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func panGesture(configuration: RxGesture.PanConfiguration? = nil) -> RxGesture.PanControlEvent
}
extension RxSwift.ObservableType where Self.E : UIKit.UIPanGestureRecognizer {
  public func asTranslation(in view: RxGesture.TargetView = .view) -> RxSwift.Observable<(translation: CoreGraphics.CGPoint, velocity: CoreGraphics.CGPoint)>
}
public typealias PinchConfiguration = RxGesture.Configuration<UIKit.UIPinchGestureRecognizer>
public typealias PinchControlEvent = RxCocoa.ControlEvent<UIKit.UIPinchGestureRecognizer>
public typealias PinchObservable = RxSwift.Observable<UIKit.UIPinchGestureRecognizer>
extension RxGesture.Factory where Gesture == RxGesture.GestureRecognizer {
  public static func pinch(configuration: RxGesture.PinchConfiguration? = nil) -> RxGesture.AnyFactory
}
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func pinchGesture(configuration: RxGesture.PinchConfiguration? = nil) -> RxGesture.PinchControlEvent
}
extension RxSwift.ObservableType where Self.E : UIKit.UIPinchGestureRecognizer {
  public func asScale() -> RxSwift.Observable<(scale: CoreGraphics.CGFloat, velocity: CoreGraphics.CGFloat)>
}
public typealias RotationConfiguration = RxGesture.Configuration<UIKit.UIRotationGestureRecognizer>
public typealias RotationControlEvent = RxCocoa.ControlEvent<UIKit.UIRotationGestureRecognizer>
public typealias RotationObservable = RxSwift.Observable<UIKit.UIRotationGestureRecognizer>
extension RxGesture.Factory where Gesture == RxGesture.GestureRecognizer {
  public static func rotation(configuration: RxGesture.RotationConfiguration? = nil) -> RxGesture.AnyFactory
}
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func rotationGesture(configuration: RxGesture.RotationConfiguration? = nil) -> RxGesture.RotationControlEvent
}
extension RxSwift.ObservableType where Self.E : UIKit.UIRotationGestureRecognizer {
  public func asRotation() -> RxSwift.Observable<(rotation: CoreGraphics.CGFloat, velocity: CoreGraphics.CGFloat)>
}
public typealias ScreenEdgePanConfiguration = RxGesture.Configuration<UIKit.UIScreenEdgePanGestureRecognizer>
public typealias ScreenEdgePanControlEvent = RxCocoa.ControlEvent<UIKit.UIScreenEdgePanGestureRecognizer>
public typealias ScreenEdgePanObservable = RxSwift.Observable<UIKit.UIScreenEdgePanGestureRecognizer>
extension RxGesture.Factory where Gesture == RxGesture.GestureRecognizer {
  public static func screenEdgePan(configuration: RxGesture.ScreenEdgePanConfiguration? = nil) -> RxGesture.AnyFactory
}
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func screenEdgePanGesture(configuration: RxGesture.ScreenEdgePanConfiguration? = nil) -> RxGesture.ScreenEdgePanControlEvent
}
public enum SwipeDirection {
  case right, left, up, down
  public static func == (a: RxGesture.SwipeDirection, b: RxGesture.SwipeDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias SwipeConfiguration = RxGesture.Configuration<UIKit.UISwipeGestureRecognizer>
public typealias SwipeControlEvent = RxCocoa.ControlEvent<UIKit.UISwipeGestureRecognizer>
public typealias SwipeObservable = RxSwift.Observable<UIKit.UISwipeGestureRecognizer>
extension RxGesture.Factory where Gesture == RxGesture.GestureRecognizer {
  public static func swipe(direction: RxGesture.SwipeDirection, configuration: RxGesture.SwipeConfiguration? = nil) -> RxGesture.AnyFactory
}
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func swipeGesture(_ directions: Swift.Set<RxGesture.SwipeDirection>, configuration: RxGesture.SwipeConfiguration? = nil) -> RxGesture.SwipeControlEvent
  public func swipeGesture(_ directions: RxGesture.SwipeDirection..., configuration: RxGesture.SwipeConfiguration? = nil) -> RxGesture.SwipeControlEvent
}
public typealias TapConfiguration = RxGesture.Configuration<UIKit.UITapGestureRecognizer>
public typealias TapControlEvent = RxCocoa.ControlEvent<UIKit.UITapGestureRecognizer>
public typealias TapObservable = RxSwift.Observable<UIKit.UITapGestureRecognizer>
extension RxGesture.Factory where Gesture == RxGesture.GestureRecognizer {
  public static func tap(configuration: RxGesture.TapConfiguration? = nil) -> RxGesture.AnyFactory
}
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func tapGesture(configuration: RxGesture.TapConfiguration? = nil) -> RxGesture.TapControlEvent
}
extension RxSwift.Reactive where Base : UIKit.UIView {
  public func anyGesture(_ factories: (RxGesture.AnyFactory, when: RxGesture.GestureRecognizerState)...) -> RxCocoa.ControlEvent<RxGesture.GestureRecognizer>
  public func anyGesture(_ factories: RxGesture.AnyFactory...) -> RxCocoa.ControlEvent<RxGesture.GestureRecognizer>
  public func gesture<G>(_ factory: RxGesture.Factory<G>) -> RxCocoa.ControlEvent<G> where G : UIKit.UIGestureRecognizer
  public func gesture<G>(_ gesture: G) -> RxCocoa.ControlEvent<G> where G : UIKit.UIGestureRecognizer
}
extension RxGesture.SwipeDirection : Swift.Equatable {}
extension RxGesture.SwipeDirection : Swift.Hashable {}
