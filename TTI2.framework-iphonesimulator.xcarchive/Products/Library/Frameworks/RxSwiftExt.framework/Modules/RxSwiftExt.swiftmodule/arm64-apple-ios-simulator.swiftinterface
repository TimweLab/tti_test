// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target arm64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RxSwiftExt
import Foundation
import RxCocoa
import RxSwift
@_exported import RxSwiftExt
import Swift
import UIKit
import _Concurrency
extension RxSwift.ObservableType where Self.E == Swift.Bool {
  public func and() -> RxSwift.Maybe<Self.E>
  public static func and<C>(_ collection: C) -> RxSwift.Maybe<Self.E> where C : Swift.Collection, C.Element : RxSwift.ObservableType, C.Element.E == Swift.Bool
  public static func and<O>(_ sources: O...) -> RxSwift.Maybe<Self.E> where O : RxSwift.ObservableType, O.E == Swift.Bool
}
extension RxSwift.ObservableType {
  public func apply<T>(_ transform: (RxSwift.Observable<Self.E>) -> RxSwift.Observable<T>) -> RxSwift.Observable<T>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public func apply<T>(_ transform: (RxSwift.Single<Self.ElementType>) -> RxSwift.Single<T>) -> RxSwift.Single<T>
}
extension RxSwift.Observable where Element : RxSwift.ObservableType {
  public typealias T = Element.E
  public static func cascade<S>(_ observables: S) -> RxSwift.Observable<RxSwift.Observable<Element>.T> where Element == S.Element, S : Swift.Sequence
}
extension RxSwift.ObservableType {
  public func cascade<S>(_ next: S) -> RxSwift.Observable<Self.E> where Self == S.Element, S : Swift.Sequence
}
extension RxSwift.ObservableType {
  public func catchErrorJustComplete() -> RxSwift.Observable<Self.E>
}
extension RxSwift.Observable {
  public func count() -> RxSwift.Observable<Swift.Int>
  public func count(_ predicate: @escaping (Element) throws -> Swift.Bool) -> RxSwift.Observable<Swift.Int>
}
extension RxSwift.Observable {
  public func distinct(_ predicate: @escaping (Element) throws -> Swift.Bool) -> RxSwift.Observable<RxSwift.Observable<Element>.E>
}
extension RxSwift.Observable where Element : Swift.Hashable {
  public func distinct() -> RxSwift.Observable<Element>
}
extension RxSwift.Observable where Element : Swift.Equatable {
  public func distinct() -> RxSwift.Observable<Element>
}
extension RxCocoa.SharedSequence {
  public func distinct(_ predicate: @escaping (Element) -> Swift.Bool) -> RxCocoa.SharedSequence<RxCocoa.SharedSequence<S, Element>.SharingStrategy, Element>
}
extension RxCocoa.SharedSequence where Element : Swift.Equatable {
  public func distinct() -> RxCocoa.SharedSequence<RxCocoa.SharedSequence<S, Element>.SharingStrategy, Element>
}
public enum FilterMap<Result> {
  case ignore
  case map(Result)
}
extension RxSwift.ObservableType {
  public func filterMap<T>(_ transform: @escaping (Self.E) -> RxSwiftExt.FilterMap<T>) -> RxSwift.Observable<T>
}
public protocol CustomOperator {
  associatedtype Result
  func apply(_ sink: (Self.Result) -> Swift.Void)
}
public struct AnyOperator<Result> : RxSwiftExt.CustomOperator {
  public typealias Sink = (Result) -> Swift.Void
  public init(_ apply: @escaping ((Result) -> Swift.Void) -> Swift.Void)
  public func apply(_ sink: (Result) -> Swift.Void)
}
extension RxSwiftExt.CustomOperator {
  public static var filter: RxSwiftExt.AnyOperator<Self.Result> {
    get
  }
  public static func map(_ values: Self.Result...) -> RxSwiftExt.AnyOperator<Self.Result>
}
extension RxSwift.ObservableType {
  public func flatMapSync<O>(_ transform: @escaping (Self.E) -> O) -> RxSwift.Observable<O.Result> where O : RxSwiftExt.CustomOperator
}
extension RxSwift.Observable {
  public static func fromAsync(_ asyncRequest: @escaping (@escaping (Element) -> Swift.Void) -> Swift.Void) -> RxSwift.Observable<Element>
  public static func fromAsync<A>(_ asyncRequest: @escaping (A, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A) -> RxSwift.Observable<Element>
  public static func fromAsync<A, B>(_ asyncRequest: @escaping (A, B, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A, B) -> RxSwift.Observable<Element>
  public static func fromAsync<A, B, C>(_ asyncRequest: @escaping (A, B, C, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A, B, C) -> RxSwift.Observable<Element>
  public static func fromAsync<A, B, C, D>(_ asyncRequest: @escaping (A, B, C, D, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A, B, C, D) -> RxSwift.Observable<Element>
  public static func fromAsync<A, B, C, D, E>(_ asyncRequest: @escaping (A, B, C, D, E, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A, B, C, D, E) -> RxSwift.Observable<Element>
  public static func fromAsync<A, B, C, D, E, F>(_ asyncRequest: @escaping (A, B, C, D, E, F, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A, B, C, D, E, F) -> RxSwift.Observable<Element>
  public static func fromAsync<A, B, C, D, E, F, G>(_ asyncRequest: @escaping (A, B, C, D, E, F, G, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A, B, C, D, E, F, G) -> RxSwift.Observable<Element>
  public static func fromAsync<A, B, C, D, E, F, G, H>(_ asyncRequest: @escaping (A, B, C, D, E, F, G, H, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A, B, C, D, E, F, G, H) -> RxSwift.Observable<Element>
  public static func fromAsync<A, B, C, D, E, F, G, H, I>(_ asyncRequest: @escaping (A, B, C, D, E, F, G, H, I, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A, B, C, D, E, F, G, H, I) -> RxSwift.Observable<Element>
  public static func fromAsync<A, B, C, D, E, F, G, H, I, J>(_ asyncRequest: @escaping (A, B, C, D, E, F, G, H, I, J, @escaping (Element) -> Swift.Void) -> Swift.Void) -> (A, B, C, D, E, F, G, H, I, J) -> RxSwift.Observable<Element>
}
extension RxSwift.ObservableType where Self.E : Swift.Equatable {
  public func ignore(_ valuesToIgnore: Self.E...) -> RxSwift.Observable<Self.E>
  public func ignore<S>(_ valuesToIgnore: S) -> RxSwift.Observable<Self.E> where S : Swift.Sequence, Self.E == S.Element
}
extension RxSwift.ObservableType {
  public func ignoreErrors() -> RxSwift.Observable<Self.E>
  public func ignoreErrors(_ predicate: @escaping (Swift.Error) -> Swift.Bool) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func ignoreWhen(_ predicate: @escaping (Self.E) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func mapAt<R>(_ keyPath: Swift.KeyPath<Self.E, R>) -> RxSwift.Observable<R>
}
extension RxSwift.ObservableType where Self.E : Swift.Collection {
  public func mapMany<T>(_ transform: @escaping (Self.E.Element) throws -> T) -> RxSwift.Observable<[T]>
}
extension RxSwift.ObservableType {
  public func mapTo<R>(_ value: R) -> RxSwift.Observable<R>
}
extension RxCocoa.SharedSequenceConvertibleType {
  public func mapTo<R>(_ value: R) -> RxCocoa.SharedSequence<Self.SharingStrategy, R>
  @available(*, deprecated, renamed: "mapTo(_:)")
  public func map<R>(to value: R) -> RxCocoa.SharedSequence<Self.SharingStrategy, R>
}
extension RxSwift.ObservableType where Self.E : RxSwift.EventConvertible {
  public func elements() -> RxSwift.Observable<Self.E.ElementType>
  public func errors() -> RxSwift.Observable<Swift.Error>
}
extension RxSwift.ObservableType where Self.E == Swift.Bool {
  public func not() -> RxSwift.Observable<Swift.Bool>
}
extension RxCocoa.SharedSequenceConvertibleType where Self.E == Swift.Bool {
  public func not() -> RxCocoa.SharedSequence<Self.SharingStrategy, Swift.Bool>
}
extension RxSwift.ObservableType {
  public func nwise(_ n: Swift.Int) -> RxSwift.Observable<[Self.E]>
  public func pairwise() -> RxSwift.Observable<(Self.E, Self.E)>
}
extension RxSwift.ObservableType {
  public func subscribe<A>(weak obj: A, _ on: @escaping (A) -> (RxSwift.Event<Self.E>) -> Swift.Void) -> RxSwift.Disposable where A : AnyObject
  public func subscribe<A>(weak obj: A, onNext: ((A) -> (Self.E) -> Swift.Void)? = nil, onError: ((A) -> (Swift.Error) -> Swift.Void)? = nil, onCompleted: ((A) -> () -> Swift.Void)? = nil, onDisposed: ((A) -> () -> Swift.Void)? = nil) -> RxSwift.Disposable where A : AnyObject
  public func subscribeNext<A>(weak obj: A, _ onNext: @escaping (A) -> (Self.E) -> Swift.Void) -> RxSwift.Disposable where A : AnyObject
  public func subscribeError<A>(weak obj: A, _ onError: @escaping (A) -> (Swift.Error) -> Swift.Void) -> RxSwift.Disposable where A : AnyObject
  public func subscribeCompleted<A>(weak obj: A, _ onCompleted: @escaping (A) -> () -> Swift.Void) -> RxSwift.Disposable where A : AnyObject
}
extension RxSwift.ObservableType {
  public func ofType<T>(_ type: T.Type) -> RxSwift.Observable<T>
}
extension RxSwift.Observable {
  public static func once(_ element: RxSwift.Observable<Element>.E) -> RxSwift.Observable<RxSwift.Observable<Element>.E>
}
extension RxSwift.ObservableType {
  public func pausable<P>(_ pauser: P) -> RxSwift.Observable<Self.E> where P : RxSwift.ObservableType, P.E == Swift.Bool
}
extension RxSwift.ObservableType {
  public func pausableBuffered<P>(_ pauser: P, limit: Swift.Int? = 1, flushOnCompleted: Swift.Bool = true, flushOnError: Swift.Bool = true) -> RxSwift.Observable<Self.E> where P : RxSwift.ObservableType, P.E == Swift.Bool
}
public typealias RepeatPredicate = () -> Swift.Bool
extension RxSwift.ObservableType {
  public func repeatWithBehavior(_ behavior: RxSwiftExt.RepeatBehavior, scheduler: RxSwift.SchedulerType = MainScheduler.instance, shouldRepeat: RxSwiftExt.RepeatPredicate? = nil) -> RxSwift.Observable<Self.E>
}
public enum RepeatBehavior {
  case immediate(maxCount: Swift.UInt)
  case delayed(maxCount: Swift.UInt, time: Swift.Double)
  case exponentialDelayed(maxCount: Swift.UInt, initial: Swift.Double, multiplier: Swift.Double)
  case customTimerDelayed(maxCount: Swift.UInt, delayCalculator: (Swift.UInt) -> Swift.Double)
}
public typealias RetryPredicate = (Swift.Error) -> Swift.Bool
extension RxSwift.ObservableType {
  public func retry(_ behavior: RxSwiftExt.RepeatBehavior, scheduler: RxSwift.SchedulerType = MainScheduler.instance, shouldRetry: RxSwiftExt.RetryPredicate? = nil) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func toSortedArray(by: @escaping (Self.E, Self.E) -> Swift.Bool) -> RxSwift.Observable<[Self.E]>
}
extension RxSwift.ObservableType where Self.E : Swift.Comparable {
  public func toSortedArray(ascending: Swift.Bool = true) -> RxSwift.Observable<[Self.E]>
}
@available(iOS 10.0, *)
extension RxSwift.Reactive where Base : UIKit.UIViewPropertyAnimator {
  public var fractionComplete: RxCocoa.Binder<CoreGraphics.CGFloat> {
    get
  }
  public func animate(afterDelay delay: Foundation.TimeInterval = 0) -> RxSwift.Completable
}
extension RxSwift.ObservableType {
  public func unwrap<T>() -> RxSwift.Observable<T> where Self.E == T?
}
extension RxCocoa.SharedSequence {
  public func unwrap<T>() -> RxCocoa.SharedSequence<S, T> where Element == T?
}
extension RxSwift.ObservableType {
  public func withUnretained<T, Out>(_ obj: T, resultSelector: @escaping ((T, Self.E)) -> Out) -> RxSwift.Observable<Out> where T : AnyObject
  public func withUnretained<T>(_ obj: T) -> RxSwift.Observable<(T, Self.E)> where T : AnyObject
}
extension RxSwift.ObservableConvertibleType {
  public func zip<O2, ResultType>(with second: O2, resultSelector: @escaping (Self.E, O2.E) throws -> ResultType) -> RxSwift.Observable<ResultType> where O2 : RxSwift.ObservableConvertibleType
}
