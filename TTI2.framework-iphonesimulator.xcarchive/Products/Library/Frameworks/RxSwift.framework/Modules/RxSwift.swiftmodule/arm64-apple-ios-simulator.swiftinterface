// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target arm64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RxSwift
import Darwin
import Dispatch
import Foundation
import Foundation/*.BlockOperation*/
import Foundation/*.Date*/
import Foundation/*.DateFormatter*/
import Foundation/*.NSCopying*/
import Foundation/*.NSLock*/
import Foundation/*.NSObject*/
import Foundation/*.NSRecursiveLock*/
import Foundation/*.Operation*/
import Foundation/*.OperationQueue*/
import Foundation/*.Thread*/
import Foundation/*.TimeInterval*/
@_exported import RxSwift
import Swift
import _Concurrency
extension RxSwift.ObservableType {
  public static func amb<S>(_ sequence: S) -> RxSwift.Observable<Self.E> where S : Swift.Sequence, S.Element == RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func amb<O2>(_ right: O2) -> RxSwift.Observable<Self.E> where O2 : RxSwift.ObservableType, Self.E == O2.E
}
extension RxSwift.Disposables {
  public static func create(with dispose: @escaping () -> Swift.Void) -> RxSwift.Cancelable
}
public struct AnyObserver<Element> : RxSwift.ObserverType {
  public typealias E = Element
  public typealias EventHandler = (RxSwift.Event<Element>) -> Swift.Void
  public init(eventHandler: @escaping RxSwift.AnyObserver<Element>.EventHandler)
  public init<O>(_ observer: O) where Element == O.E, O : RxSwift.ObserverType
  public func on(_ event: RxSwift.Event<Element>)
  public func asObserver() -> RxSwift.AnyObserver<RxSwift.AnyObserver<Element>.E>
}
extension RxSwift.ObserverType {
  public func asObserver() -> RxSwift.AnyObserver<Self.E>
  public func mapObserver<R>(_ transform: @escaping (R) throws -> Self.E) -> RxSwift.AnyObserver<R>
}
@_inheritsConvenienceInitializers final public class AsyncSubject<Element> : RxSwift.Observable<Element>, RxSwift.SubjectType, RxSwift.ObserverType {
  public typealias SubjectObserverType = RxSwift.AsyncSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  public init()
  final public func on(_ event: RxSwift.Event<RxSwift.AsyncSubject<Element>.E>)
  override final public func subscribe<O>(_ observer: O) -> RxSwift.Disposable where Element == O.E, O : RxSwift.ObserverType
  final public func asObserver() -> RxSwift.AsyncSubject<Element>
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class BehaviorSubject<Element> : RxSwift.Observable<Element>, RxSwift.SubjectType, RxSwift.ObserverType, RxSwift.Cancelable {
  public typealias SubjectObserverType = RxSwift.BehaviorSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(value: Element)
  final public func value() throws -> Element
  final public func on(_ event: RxSwift.Event<RxSwift.BehaviorSubject<Element>.E>)
  override final public func subscribe<O>(_ observer: O) -> RxSwift.Disposable where Element == O.E, O : RxSwift.ObserverType
  final public func asObserver() -> RxSwift.BehaviorSubject<Element>
  final public func dispose()
  @objc deinit
}
extension RxSwift.Disposables {
  public static func create(_ disposable1: RxSwift.Disposable, _ disposable2: RxSwift.Disposable) -> RxSwift.Cancelable
}
final public class BooleanDisposable : RxSwift.Cancelable {
  public init()
  public init(isDisposed: Swift.Bool)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
  @objc deinit
}
extension RxSwift.ObservableType {
  public func buffer(timeSpan: RxSwift.RxTimeInterval, count: Swift.Int, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<[Self.E]>
}
public protocol Cancelable : RxSwift.Disposable {
  var isDisposed: Swift.Bool { get }
}
extension RxSwift.ObservableType {
  public func catchError(_ handler: @escaping (Swift.Error) throws -> RxSwift.Observable<Self.E>) -> RxSwift.Observable<Self.E>
  public func catchErrorJustReturn(_ element: Self.E) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public static func catchError<S>(_ sequence: S) -> RxSwift.Observable<Self.E> where S : Swift.Sequence, S.Element == RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func retry() -> RxSwift.Observable<Self.E>
  public func retry(_ maxAttemptCount: Swift.Int) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> RxSwift.Observable<(O1.E, O2.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> RxSwift.Observable<(O1.E, O2.E, O3.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E, O5.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType, O7 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType, O7 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType, O7 : RxSwift.ObservableType, O8 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType, O7 : RxSwift.ObservableType, O8 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func combineLatest<C>(_ collection: C, _ resultSelector: @escaping ([C.Iterator.Element.E]) throws -> Self.E) -> RxSwift.Observable<Self.E> where C : Swift.Collection, C.Element : RxSwift.ObservableType
  public static func combineLatest<C>(_ collection: C) -> RxSwift.Observable<[Self.E]> where C : Swift.Collection, Self.E == C.Element.E, C.Element : RxSwift.ObservableType
}
public enum CompletableTrait {
}
public typealias Completable = RxSwift.PrimitiveSequence<RxSwift.CompletableTrait, Swift.Never>
public enum CompletableEvent {
  case error(Swift.Error)
  case completed
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Swift.Never, Self.TraitType == RxSwift.CompletableTrait {
  public typealias CompletableObserver = (RxSwift.CompletableEvent) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.CompletableObserver) -> RxSwift.Disposable) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
  public func subscribe(_ observer: @escaping (RxSwift.CompletableEvent) -> Swift.Void) -> RxSwift.Disposable
  public func subscribe(onCompleted: (() -> Swift.Void)? = nil, onError: ((Swift.Error) -> Swift.Void)? = nil) -> RxSwift.Disposable
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Swift.Never, Self.TraitType == RxSwift.CompletableTrait {
  public static func error(_ error: Swift.Error) -> RxSwift.Completable
  public static func never() -> RxSwift.Completable
  public static func empty() -> RxSwift.Completable
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Swift.Never, Self.TraitType == RxSwift.CompletableTrait {
  public func `do`(onError: ((Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> RxSwift.Completable
  public func concat(_ second: RxSwift.Completable) -> RxSwift.Completable
  public static func concat<S>(_ sequence: S) -> RxSwift.Completable where S : Swift.Sequence, S.Element == RxSwift.Completable
  public static func concat<C>(_ collection: C) -> RxSwift.Completable where C : Swift.Collection, C.Element == RxSwift.Completable
  public static func concat(_ sources: RxSwift.Completable...) -> RxSwift.Completable
  public static func merge<C>(_ sources: C) -> RxSwift.Completable where C : Swift.Collection, C.Element == RxSwift.Completable
  public static func merge(_ sources: [RxSwift.Completable]) -> RxSwift.Completable
  public static func merge(_ sources: RxSwift.Completable...) -> RxSwift.Completable
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Swift.Never, Self.TraitType == RxSwift.CompletableTrait {
  public func andThen<E>(_ second: RxSwift.Single<E>) -> RxSwift.Single<E>
  public func andThen<E>(_ second: RxSwift.Maybe<E>) -> RxSwift.Maybe<E>
  public func andThen(_ second: RxSwift.Completable) -> RxSwift.Completable
  public func andThen<E>(_ second: RxSwift.Observable<E>) -> RxSwift.Observable<E>
}
@_inheritsConvenienceInitializers final public class CompositeDisposable : RxSwift.DisposeBase, RxSwift.Cancelable {
  public struct DisposeKey {
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  public init(_ disposable1: RxSwift.Disposable, _ disposable2: RxSwift.Disposable)
  public init(_ disposable1: RxSwift.Disposable, _ disposable2: RxSwift.Disposable, _ disposable3: RxSwift.Disposable)
  public init(_ disposable1: RxSwift.Disposable, _ disposable2: RxSwift.Disposable, _ disposable3: RxSwift.Disposable, _ disposable4: RxSwift.Disposable, _ disposables: RxSwift.Disposable...)
  public init(disposables: [RxSwift.Disposable])
  final public func insert(_ disposable: RxSwift.Disposable) -> RxSwift.CompositeDisposable.DisposeKey?
  final public var count: Swift.Int {
    get
  }
  final public func remove(for disposeKey: RxSwift.CompositeDisposable.DisposeKey)
  final public func dispose()
  @objc deinit
}
extension RxSwift.Disposables {
  public static func create(_ disposable1: RxSwift.Disposable, _ disposable2: RxSwift.Disposable, _ disposable3: RxSwift.Disposable) -> RxSwift.Cancelable
  public static func create(_ disposable1: RxSwift.Disposable, _ disposable2: RxSwift.Disposable, _ disposable3: RxSwift.Disposable, _ disposables: RxSwift.Disposable...) -> RxSwift.Cancelable
  public static func create(_ disposables: [RxSwift.Disposable]) -> RxSwift.Cancelable
}
extension RxSwift.ObservableType {
  public func concat<O>(_ second: O) -> RxSwift.Observable<Self.E> where O : RxSwift.ObservableConvertibleType, Self.E == O.E
}
extension RxSwift.ObservableType {
  public static func concat<S>(_ sequence: S) -> RxSwift.Observable<Self.E> where S : Swift.Sequence, S.Element == RxSwift.Observable<Self.E>
  public static func concat<S>(_ collection: S) -> RxSwift.Observable<Self.E> where S : Swift.Collection, S.Element == RxSwift.Observable<Self.E>
  public static func concat(_ sources: RxSwift.Observable<Self.E>...) -> RxSwift.Observable<Self.E>
}
public class ConcurrentDispatchQueueScheduler : RxSwift.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  public init(queue: Dispatch.DispatchQueue, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  @available(iOS 8, macOS 10.10, *)
  convenience public init(qos: Dispatch.DispatchQoS, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: RxSwift.ConcurrentDispatchQueueScheduler.TimeInterval, period: RxSwift.ConcurrentDispatchQueueScheduler.TimeInterval, action: @escaping (StateType) -> StateType) -> RxSwift.Disposable
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ConcurrentMainScheduler : RxSwift.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  final public var now: Foundation.Date {
    get
  }
  public static let instance: RxSwift.ConcurrentMainScheduler
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  final public func schedulePeriodic<StateType>(_ state: StateType, startAfter: RxSwift.ConcurrentMainScheduler.TimeInterval, period: RxSwift.ConcurrentMainScheduler.TimeInterval, action: @escaping (StateType) -> StateType) -> RxSwift.Disposable
  @objc deinit
}
public protocol ConnectableObservableType : RxSwift.ObservableType {
  func connect() -> RxSwift.Disposable
}
extension RxSwift.ObservableType {
  public static func create(_ subscribe: @escaping (RxSwift.AnyObserver<Self.E>) -> RxSwift.Disposable) -> RxSwift.Observable<Self.E>
}
@_hasMissingDesignatedInitializers public class CurrentThreadScheduler : RxSwift.ImmediateSchedulerType {
  public static let instance: RxSwift.CurrentThreadScheduler
  public static var isScheduleRequired: Swift.Bool {
    get
  }
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  @objc deinit
}
extension RxSwift.ObservableType {
  public func debounce(_ dueTime: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func ifEmpty(default: Self.E) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public static func deferred(_ observableFactory: @escaping () throws -> RxSwift.Observable<Self.E>) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func delay(_ dueTime: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func delaySubscription(_ dueTime: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType where Self.E : RxSwift.EventConvertible {
  public func dematerialize() -> RxSwift.Observable<Self.E.ElementType>
}
extension RxSwift.Observable {
  @available(*, deprecated, renamed: "from(optional:)", message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.")
  public static func from(_ optional: RxSwift.Observable<Element>.E?) -> RxSwift.Observable<RxSwift.Observable<Element>.E>
  @available(*, deprecated, renamed: "from(optional:scheduler:)", message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.")
  public static func from(_ optional: RxSwift.Observable<Element>.E?, scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.Observable<RxSwift.Observable<Element>.E>
}
extension RxSwift.ObservableType {
  @available(*, deprecated, message: "Please use enumerated().map()")
  public func mapWithIndex<R>(_ selector: @escaping (Self.E, Swift.Int) throws -> R) -> RxSwift.Observable<R>
  @available(*, deprecated, message: "Please use enumerated().flatMap()")
  public func flatMapWithIndex<O>(_ selector: @escaping (Self.E, Swift.Int) throws -> O) -> RxSwift.Observable<O.E> where O : RxSwift.ObservableConvertibleType
  @available(*, deprecated, message: "Please use enumerated().skipWhile().map()")
  public func skipWhileWithIndex(_ predicate: @escaping (Self.E, Swift.Int) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
  @available(*, deprecated, message: "Please use enumerated().takeWhile().map()")
  public func takeWhileWithIndex(_ predicate: @escaping (Self.E, Swift.Int) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
}
extension RxSwift.Disposable {
  @available(*, deprecated, renamed: "disposed(by:)", message: "use disposed(by:) instead")
  public func addDisposableTo(_ bag: RxSwift.DisposeBag)
}
extension RxSwift.ObservableType {
  @available(*, deprecated, renamed: "share(replay:)", message: "use share(replay: 1) instead")
  public func shareReplayLatestWhileConnected() -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  @available(*, deprecated, renamed: "share(replay:)", message: "Suggested replacement is `share(replay: 1)`. In case old 3.x behavior of `shareReplay` is required please use `share(replay: 1, scope: .forever)` instead.")
  public func shareReplay(_ bufferSize: Swift.Int) -> RxSwift.Observable<Self.E>
}
final public class Variable<Element> {
  public typealias E = Element
  final public var value: RxSwift.Variable<Element>.E {
    get
    set(newValue)
  }
  public init(_ value: Element)
  final public func asObservable() -> RxSwift.Observable<RxSwift.Variable<Element>.E>
  @objc deinit
}
public protocol Disposable {
  func dispose()
}
public struct Disposables {
}
extension RxSwift.Disposable {
  public func disposed(by bag: RxSwift.DisposeBag)
}
@_inheritsConvenienceInitializers final public class DisposeBag : RxSwift.DisposeBase {
  public init()
  final public func insert(_ disposable: RxSwift.Disposable)
  @objc deinit
}
extension RxSwift.DisposeBag {
  convenience public init(disposing disposables: RxSwift.Disposable...)
  convenience public init(disposing disposables: [RxSwift.Disposable])
  final public func insert(_ disposables: RxSwift.Disposable...)
  final public func insert(_ disposables: [RxSwift.Disposable])
}
@_hasMissingDesignatedInitializers public class DisposeBase {
  @objc deinit
}
extension RxSwift.ObservableType where Self.E : Swift.Equatable {
  public func distinctUntilChanged() -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.E) throws -> K) -> RxSwift.Observable<Self.E> where K : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.E, Self.E) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.E) throws -> K, comparer: @escaping (K, K) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func `do`(onNext: ((Self.E) throws -> Swift.Void)? = nil, onError: ((Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func elementAt(_ index: Swift.Int) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public static func empty() -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func enumerated() -> RxSwift.Observable<(index: Swift.Int, element: Self.E)>
}
extension RxSwift.ObservableType {
  public static func error(_ error: Swift.Error) -> RxSwift.Observable<Self.E>
}
public enum RxError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case disposed(object: Swift.AnyObject)
  case overflow
  case argumentOutOfRange
  case noElements
  case moreThanOneElement
  case timeout
}
extension RxSwift.RxError {
  public var debugDescription: Swift.String {
    get
  }
}
public enum Event<Element> {
  case next(Element)
  case error(Swift.Error)
  case completed
}
extension RxSwift.Event : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RxSwift.Event {
  public var isStopEvent: Swift.Bool {
    get
  }
  public var element: Element? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public var isCompleted: Swift.Bool {
    get
  }
}
extension RxSwift.Event {
  public func map<Result>(_ transform: (Element) throws -> Result) -> RxSwift.Event<Result>
}
public protocol EventConvertible {
  associatedtype ElementType
  var event: RxSwift.Event<Self.ElementType> { get }
}
extension RxSwift.Event : RxSwift.EventConvertible {
  public var event: RxSwift.Event<Element> {
    get
  }
  public typealias ElementType = Element
}
extension RxSwift.ObservableType {
  public func filter(_ predicate: @escaping (Self.E) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func ignoreElements() -> RxSwift.Completable
}
extension RxSwift.ObservableType {
  public static func generate(initialState: Self.E, condition: @escaping (Self.E) throws -> Swift.Bool, scheduler: RxSwift.ImmediateSchedulerType = CurrentThreadScheduler.instance, iterate: @escaping (Self.E) throws -> Self.E) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func groupBy<K>(keySelector: @escaping (Self.E) throws -> K) -> RxSwift.Observable<RxSwift.GroupedObservable<K, Self.E>> where K : Swift.Hashable
}
public struct GroupedObservable<Key, Element> : RxSwift.ObservableType {
  public typealias E = Element
  public let key: Key
  public init(key: Key, source: RxSwift.Observable<Element>)
  public func subscribe<O>(_ observer: O) -> RxSwift.Disposable where Element == O.E, O : RxSwift.ObserverType
  public func asObservable() -> RxSwift.Observable<Element>
}
public class HistoricalScheduler : RxSwift.VirtualTimeScheduler<RxSwift.HistoricalSchedulerTimeConverter> {
  public init(initialClock: RxSwift.RxTime = Date(timeIntervalSince1970: 0))
  @objc deinit
}
public struct HistoricalSchedulerTimeConverter : RxSwift.VirtualTimeConverterType {
  public typealias VirtualTimeUnit = RxSwift.RxTime
  public typealias VirtualTimeIntervalUnit = RxSwift.RxTimeInterval
  public func convertFromVirtualTime(_ virtualTime: RxSwift.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> RxSwift.RxTime
  public func convertToVirtualTime(_ time: RxSwift.RxTime) -> RxSwift.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func convertFromVirtualTimeInterval(_ virtualTimeInterval: RxSwift.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> RxSwift.RxTimeInterval
  public func convertToVirtualTimeInterval(_ timeInterval: RxSwift.RxTimeInterval) -> RxSwift.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit
  public func offsetVirtualTime(_ time: RxSwift.HistoricalSchedulerTimeConverter.VirtualTimeUnit, offset: RxSwift.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> RxSwift.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func compareVirtualTime(_ lhs: RxSwift.HistoricalSchedulerTimeConverter.VirtualTimeUnit, _ rhs: RxSwift.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> RxSwift.VirtualTimeComparison
}
public protocol ImmediateSchedulerType {
  func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
}
extension RxSwift.ImmediateSchedulerType {
  public func scheduleRecursive<State>(_ state: State, action: @escaping (_ state: State, _ recurse: (State) -> Swift.Void) -> Swift.Void) -> RxSwift.Disposable
}
extension RxSwift.ObservableType {
  public static func just(_ element: Self.E) -> RxSwift.Observable<Self.E>
  public static func just(_ element: Self.E, scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.Observable<Self.E>
}
@_hasMissingDesignatedInitializers final public class MainScheduler : RxSwift.SerialDispatchQueueScheduler {
  public init()
  public static let instance: RxSwift.MainScheduler
  public static let asyncInstance: RxSwift.SerialDispatchQueueScheduler
  final public class func ensureExecutingOnScheduler(errorMessage: Swift.String? = nil)
  final public class func ensureRunningOnMainThread(errorMessage: Swift.String? = nil)
  @objc deinit
}
extension RxSwift.ObservableType {
  public func map<R>(_ transform: @escaping (Self.E) throws -> R) -> RxSwift.Observable<R>
}
extension RxSwift.ObservableType {
  public func materialize() -> RxSwift.Observable<RxSwift.Event<Self.E>>
}
public enum MaybeTrait {
}
public typealias Maybe<Element> = RxSwift.PrimitiveSequence<RxSwift.MaybeTrait, Element>
public enum MaybeEvent<Element> {
  case success(Element)
  case error(Swift.Error)
  case completed
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public typealias MaybeObserver = (RxSwift.MaybeEvent<Self.ElementType>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.MaybeObserver) -> RxSwift.Disposable) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
  public func subscribe(_ observer: @escaping (RxSwift.MaybeEvent<Self.ElementType>) -> Swift.Void) -> RxSwift.Disposable
  public func subscribe(onSuccess: ((Self.ElementType) -> Swift.Void)? = nil, onError: ((Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil) -> RxSwift.Disposable
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public static func just(_ element: Self.ElementType) -> RxSwift.Maybe<Self.ElementType>
  public static func just(_ element: Self.ElementType, scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.Maybe<Self.ElementType>
  public static func error(_ error: Swift.Error) -> RxSwift.Maybe<Self.ElementType>
  public static func never() -> RxSwift.Maybe<Self.ElementType>
  public static func empty() -> RxSwift.Maybe<Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public func `do`(onNext: ((Self.ElementType) throws -> Swift.Void)? = nil, onError: ((Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> RxSwift.Maybe<Self.ElementType>
  public func filter(_ predicate: @escaping (Self.ElementType) throws -> Swift.Bool) -> RxSwift.Maybe<Self.ElementType>
  public func map<R>(_ transform: @escaping (Self.ElementType) throws -> R) -> RxSwift.Maybe<R>
  public func flatMap<R>(_ selector: @escaping (Self.ElementType) throws -> RxSwift.Maybe<R>) -> RxSwift.Maybe<R>
  public func ifEmpty(default: Self.ElementType) -> RxSwift.Single<Self.ElementType>
  public func ifEmpty(switchTo other: RxSwift.Maybe<Self.ElementType>) -> RxSwift.Maybe<Self.ElementType>
  public func ifEmpty(switchTo other: RxSwift.Single<Self.ElementType>) -> RxSwift.Single<Self.ElementType>
  public func catchErrorJustReturn(_ element: Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.ObservableType {
  public func flatMap<O>(_ selector: @escaping (Self.E) throws -> O) -> RxSwift.Observable<O.E> where O : RxSwift.ObservableConvertibleType
}
extension RxSwift.ObservableType {
  public func flatMapFirst<O>(_ selector: @escaping (Self.E) throws -> O) -> RxSwift.Observable<O.E> where O : RxSwift.ObservableConvertibleType
}
extension RxSwift.ObservableType where Self.E : RxSwift.ObservableConvertibleType {
  public func merge() -> RxSwift.Observable<Self.E.E>
  public func merge(maxConcurrent: Swift.Int) -> RxSwift.Observable<Self.E.E>
}
extension RxSwift.ObservableType where Self.E : RxSwift.ObservableConvertibleType {
  public func concat() -> RxSwift.Observable<Self.E.E>
}
extension RxSwift.ObservableType {
  public static func merge<C>(_ sources: C) -> RxSwift.Observable<Self.E> where C : Swift.Collection, C.Element == RxSwift.Observable<Self.E>
  public static func merge(_ sources: [RxSwift.Observable<Self.E>]) -> RxSwift.Observable<Self.E>
  public static func merge(_ sources: RxSwift.Observable<Self.E>...) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func concatMap<O>(_ selector: @escaping (Self.E) throws -> O) -> RxSwift.Observable<O.E> where O : RxSwift.ObservableConvertibleType
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ConnectableObservable<Element> : RxSwift.Observable<Element>, RxSwift.ConnectableObservableType {
  public func connect() -> RxSwift.Disposable
  @objc deinit
}
extension RxSwift.ObservableType {
  public func multicast<S, R>(_ subjectSelector: @escaping () throws -> S, selector: @escaping (RxSwift.Observable<S.E>) throws -> RxSwift.Observable<R>) -> RxSwift.Observable<R> where S : RxSwift.SubjectType, Self.E == S.SubjectObserverType.E
}
extension RxSwift.ObservableType {
  public func publish() -> RxSwift.ConnectableObservable<Self.E>
}
extension RxSwift.ObservableType {
  public func replay(_ bufferSize: Swift.Int) -> RxSwift.ConnectableObservable<Self.E>
  public func replayAll() -> RxSwift.ConnectableObservable<Self.E>
}
extension RxSwift.ConnectableObservableType {
  public func refCount() -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func multicast<S>(_ subject: S) -> RxSwift.ConnectableObservable<S.E> where S : RxSwift.SubjectType, Self.E == S.SubjectObserverType.E
  public func multicast<S>(makeSubject: @escaping () -> S) -> RxSwift.ConnectableObservable<S.E> where S : RxSwift.SubjectType, Self.E == S.SubjectObserverType.E
}
extension RxSwift.ObservableType {
  public static func never() -> RxSwift.Observable<Self.E>
}
extension RxSwift.Disposables {
  public static func create() -> RxSwift.Disposable
}
@_hasMissingDesignatedInitializers public class Observable<Element> : RxSwift.ObservableType {
  public typealias E = Element
  public func subscribe<O>(_ observer: O) -> RxSwift.Disposable where Element == O.E, O : RxSwift.ObserverType
  public func asObservable() -> RxSwift.Observable<RxSwift.Observable<Element>.E>
  @objc deinit
}
public protocol ObservableConvertibleType {
  associatedtype E
  func asObservable() -> RxSwift.Observable<Self.E>
}
public protocol ObservableType : RxSwift.ObservableConvertibleType {
  func subscribe<O>(_ observer: O) -> RxSwift.Disposable where O : RxSwift.ObserverType, Self.E == O.E
}
extension RxSwift.ObservableType {
  public func asObservable() -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func subscribe(_ on: @escaping (RxSwift.Event<Self.E>) -> Swift.Void) -> RxSwift.Disposable
  public func subscribe(onNext: ((Self.E) -> Swift.Void)? = nil, onError: ((Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> RxSwift.Disposable
}
extension RxSwift.Hooks {
  public typealias DefaultErrorHandler = (_ subscriptionCallStack: [Swift.String], _ error: Swift.Error) -> Swift.Void
  public typealias CustomCaptureSubscriptionCallstack = () -> [Swift.String]
  public static var defaultErrorHandler: RxSwift.Hooks.DefaultErrorHandler {
    get
    set
  }
  public static var customCaptureSubscriptionCallstack: RxSwift.Hooks.CustomCaptureSubscriptionCallstack {
    get
    set
  }
}
extension RxSwift.ObservableType {
  public func asSingle() -> RxSwift.Single<Self.E>
  public func first() -> RxSwift.Single<Self.E?>
  public func asMaybe() -> RxSwift.Maybe<Self.E>
}
extension RxSwift.ObservableType where Self.E == Swift.Never {
  public func asCompletable() -> RxSwift.Completable
}
extension RxSwift.ObservableType {
  public func observeOn(_ scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.Observable<Self.E>
}
public protocol ObserverType {
  associatedtype E
  func on(_ event: RxSwift.Event<Self.E>)
}
extension RxSwift.ObserverType {
  public func onNext(_ element: Self.E)
  public func onCompleted()
  public func onError(_ error: Swift.Error)
}
public class OperationQueueScheduler : RxSwift.ImmediateSchedulerType {
  final public let operationQueue: Foundation.OperationQueue
  final public let queuePriority: Foundation.Operation.QueuePriority
  public init(operationQueue: Foundation.OperationQueue, queuePriority: Foundation.Operation.QueuePriority = .normal)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  @objc deinit
}
extension RxSwift.ObservableType {
  public static func from(optional: Self.E?) -> RxSwift.Observable<Self.E>
  public static func from(optional: Self.E?, scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.Observable<Self.E>
}
public struct PrimitiveSequence<Trait, Element> {
}
public protocol PrimitiveSequenceType {
  associatedtype TraitType
  associatedtype ElementType
  var primitiveSequence: RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType> { get }
}
extension RxSwift.PrimitiveSequence : RxSwift.PrimitiveSequenceType {
  public typealias TraitType = Trait
  public typealias ElementType = Element
  public var primitiveSequence: RxSwift.PrimitiveSequence<RxSwift.PrimitiveSequence<Trait, Element>.TraitType, RxSwift.PrimitiveSequence<Trait, Element>.ElementType> {
    get
  }
}
extension RxSwift.PrimitiveSequence : RxSwift.ObservableConvertibleType {
  public typealias E = Element
  public func asObservable() -> RxSwift.Observable<RxSwift.PrimitiveSequence<Trait, Element>.E>
}
extension RxSwift.PrimitiveSequence {
  public static func deferred(_ observableFactory: @escaping () throws -> RxSwift.PrimitiveSequence<Trait, Element>) -> RxSwift.PrimitiveSequence<Trait, Element>
  public func delay(_ dueTime: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.PrimitiveSequence<Trait, Element>
  public func delaySubscription(_ dueTime: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.PrimitiveSequence<Trait, Element>
  public func observeOn(_ scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.PrimitiveSequence<Trait, Element>
  public func subscribeOn(_ scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.PrimitiveSequence<Trait, Element>
  public func catchError(_ handler: @escaping (Swift.Error) throws -> RxSwift.PrimitiveSequence<Trait, Element>) -> RxSwift.PrimitiveSequence<Trait, Element>
  public func retry(_ maxAttemptCount: Swift.Int) -> RxSwift.PrimitiveSequence<Trait, Element>
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (RxSwift.Observable<Error>) -> TriggerObservable) -> RxSwift.PrimitiveSequence<Trait, Element> where TriggerObservable : RxSwift.ObservableType, Error : Swift.Error
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (RxSwift.Observable<Swift.Error>) -> TriggerObservable) -> RxSwift.PrimitiveSequence<Trait, Element> where TriggerObservable : RxSwift.ObservableType
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> RxSwift.PrimitiveSequence<Trait, Element>
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, primitiveSequenceFactory: @escaping (Resource) throws -> RxSwift.PrimitiveSequence<Trait, Element>) -> RxSwift.PrimitiveSequence<Trait, Element> where Resource : RxSwift.Disposable
  public func timeout(_ dueTime: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.PrimitiveSequence<Trait, Element>
  public func timeout(_ dueTime: RxSwift.RxTimeInterval, other: RxSwift.PrimitiveSequence<Trait, Element>, scheduler: RxSwift.SchedulerType) -> RxSwift.PrimitiveSequence<Trait, Element>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, resultSelector: @escaping (E1, E2) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, resultSelector: @escaping (E1, E2) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4, E5)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4, E5)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4, E5, E6)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4, E5, E6)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, _ source7: RxSwift.PrimitiveSequence<Self.TraitType, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, _ source7: RxSwift.PrimitiveSequence<Self.TraitType, E7>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4, E5, E6, E7)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, _ source7: RxSwift.PrimitiveSequence<Self.TraitType, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, _ source7: RxSwift.PrimitiveSequence<Self.TraitType, E7>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4, E5, E6, E7)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, _ source7: RxSwift.PrimitiveSequence<Self.TraitType, E7>, _ source8: RxSwift.PrimitiveSequence<Self.TraitType, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, _ source7: RxSwift.PrimitiveSequence<Self.TraitType, E7>, _ source8: RxSwift.PrimitiveSequence<Self.TraitType, E8>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, _ source7: RxSwift.PrimitiveSequence<Self.TraitType, E7>, _ source8: RxSwift.PrimitiveSequence<Self.TraitType, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.ElementType == Any, Self.TraitType == RxSwift.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: RxSwift.PrimitiveSequence<Self.TraitType, E1>, _ source2: RxSwift.PrimitiveSequence<Self.TraitType, E2>, _ source3: RxSwift.PrimitiveSequence<Self.TraitType, E3>, _ source4: RxSwift.PrimitiveSequence<Self.TraitType, E4>, _ source5: RxSwift.PrimitiveSequence<Self.TraitType, E5>, _ source6: RxSwift.PrimitiveSequence<Self.TraitType, E6>, _ source7: RxSwift.PrimitiveSequence<Self.TraitType, E7>, _ source8: RxSwift.PrimitiveSequence<Self.TraitType, E8>) -> RxSwift.PrimitiveSequence<Self.TraitType, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
@_inheritsConvenienceInitializers final public class PublishSubject<Element> : RxSwift.Observable<Element>, RxSwift.SubjectType, RxSwift.Cancelable, RxSwift.ObserverType {
  public typealias SubjectObserverType = RxSwift.PublishSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public func on(_ event: RxSwift.Event<Element>)
  override final public func subscribe<O>(_ observer: O) -> RxSwift.Disposable where Element == O.E, O : RxSwift.ObserverType
  final public func asObserver() -> RxSwift.PublishSubject<Element>
  final public func dispose()
  @objc deinit
}
extension RxSwift.ObservableType where Self.E : Swift.FixedWidthInteger {
  public static func range(start: Self.E, count: Self.E, scheduler: RxSwift.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> RxSwift.Observable<Self.E>
}
public struct Reactive<Base> {
  public let base: Base
  public init(_ base: Base)
}
public protocol ReactiveCompatible {
  associatedtype CompatibleType
  static var rx: RxSwift.Reactive<Self.CompatibleType>.Type { get set }
  var rx: RxSwift.Reactive<Self.CompatibleType> { get set }
}
extension RxSwift.ReactiveCompatible {
  public static var rx: RxSwift.Reactive<Self>.Type {
    get
    set
  }
  public var rx: RxSwift.Reactive<Self> {
    get
    set
  }
}
extension ObjectiveC.NSObject : RxSwift.ReactiveCompatible {
  public typealias CompatibleType = ObjectiveC.NSObject
}
extension RxSwift.ObservableType {
  public func reduce<A, R>(_ seed: A, accumulator: @escaping (A, Self.E) throws -> A, mapResult: @escaping (A) throws -> R) -> RxSwift.Observable<R>
  public func reduce<A>(_ seed: A, accumulator: @escaping (A, Self.E) throws -> A) -> RxSwift.Observable<A>
}
@_hasMissingDesignatedInitializers final public class RefCountDisposable : RxSwift.DisposeBase, RxSwift.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(disposable: RxSwift.Disposable)
  final public func retain() -> RxSwift.Disposable
  final public func dispose()
  @objc deinit
}
extension RxSwift.ObservableType {
  public static func repeatElement(_ element: Self.E, scheduler: RxSwift.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> RxSwift.Observable<Self.E>
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ReplaySubject<Element> : RxSwift.Observable<Element>, RxSwift.SubjectType, RxSwift.ObserverType, RxSwift.Disposable {
  public typealias SubjectObserverType = RxSwift.ReplaySubject<Element>
  public var hasObservers: Swift.Bool {
    get
  }
  public func on(_ event: RxSwift.Event<RxSwift.ReplaySubject<Element>.E>)
  public func asObserver() -> RxSwift.ReplaySubject<Element>.SubjectObserverType
  public func dispose()
  public static func create(bufferSize: Swift.Int) -> RxSwift.ReplaySubject<Element>
  public static func createUnbounded() -> RxSwift.ReplaySubject<Element>
  @objc deinit
}
extension RxSwift.ObservableType {
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (RxSwift.Observable<Error>) -> TriggerObservable) -> RxSwift.Observable<Self.E> where TriggerObservable : RxSwift.ObservableType, Error : Swift.Error
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (RxSwift.Observable<Swift.Error>) -> TriggerObservable) -> RxSwift.Observable<Self.E> where TriggerObservable : RxSwift.ObservableType
}
public enum Hooks {
  public static var recordCallStackOnError: Swift.Bool
}
extension RxSwift.ObservableType {
  public func sample<O>(_ sampler: O) -> RxSwift.Observable<Self.E> where O : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public func scan<A>(into seed: A, accumulator: @escaping (inout A, Self.E) throws -> Swift.Void) -> RxSwift.Observable<A>
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.E) throws -> A) -> RxSwift.Observable<A>
}
final public class ScheduledDisposable : RxSwift.Cancelable {
  final public let scheduler: RxSwift.ImmediateSchedulerType
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(scheduler: RxSwift.ImmediateSchedulerType, disposable: RxSwift.Disposable)
  final public func dispose()
  @objc deinit
}
public typealias RxTimeInterval = Foundation.TimeInterval
public typealias RxTime = Foundation.Date
public protocol SchedulerType : RxSwift.ImmediateSchedulerType {
  var now: RxSwift.RxTime { get }
  func scheduleRelative<StateType>(_ state: StateType, dueTime: RxSwift.RxTimeInterval, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  func schedulePeriodic<StateType>(_ state: StateType, startAfter: RxSwift.RxTimeInterval, period: RxSwift.RxTimeInterval, action: @escaping (StateType) -> StateType) -> RxSwift.Disposable
}
extension RxSwift.SchedulerType {
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: RxSwift.RxTimeInterval, period: RxSwift.RxTimeInterval, action: @escaping (StateType) -> StateType) -> RxSwift.Disposable
}
extension RxSwift.ObservableType {
  public static func of(_ elements: Self.E..., scheduler: RxSwift.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public static func from(_ array: [Self.E], scheduler: RxSwift.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> RxSwift.Observable<Self.E>
  public static func from<S>(_ sequence: S, scheduler: RxSwift.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> RxSwift.Observable<Self.E> where S : Swift.Sequence, Self.E == S.Element
}
@_hasMissingDesignatedInitializers public class SerialDispatchQueueScheduler : RxSwift.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  convenience public init(internalSerialQueueName: Swift.String, serialQueueConfiguration: ((Dispatch.DispatchQueue) -> Swift.Void)? = nil, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  convenience public init(queue: Dispatch.DispatchQueue, internalSerialQueueName: Swift.String, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  @available(iOS 8, macOS 10.10, *)
  convenience public init(qos: Dispatch.DispatchQoS, internalSerialQueueName: Swift.String = "rx.global_dispatch_queue.serial", leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: RxSwift.SerialDispatchQueueScheduler.TimeInterval, period: RxSwift.SerialDispatchQueueScheduler.TimeInterval, action: @escaping (StateType) -> StateType) -> RxSwift.Disposable
  @objc deinit
}
@_inheritsConvenienceInitializers final public class SerialDisposable : RxSwift.DisposeBase, RxSwift.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public var disposable: RxSwift.Disposable {
    get
    set(newDisposable)
  }
  final public func dispose()
  @objc deinit
}
public enum SubjectLifetimeScope {
  case whileConnected
  case forever
  public static func == (a: RxSwift.SubjectLifetimeScope, b: RxSwift.SubjectLifetimeScope) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RxSwift.ObservableType {
  public func share(replay: Swift.Int = 0, scope: RxSwift.SubjectLifetimeScope = .whileConnected) -> RxSwift.Observable<Self.E>
}
public enum SingleTrait {
}
public typealias Single<Element> = RxSwift.PrimitiveSequence<RxSwift.SingleTrait, Element>
public enum SingleEvent<Element> {
  case success(Element)
  case error(Swift.Error)
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public typealias SingleObserver = (RxSwift.SingleEvent<Self.ElementType>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.SingleObserver) -> RxSwift.Disposable) -> RxSwift.Single<Self.ElementType>
  public func subscribe(_ observer: @escaping (RxSwift.SingleEvent<Self.ElementType>) -> Swift.Void) -> RxSwift.Disposable
  public func subscribe(onSuccess: ((Self.ElementType) -> Swift.Void)? = nil, onError: ((Swift.Error) -> Swift.Void)? = nil) -> RxSwift.Disposable
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public static func just(_ element: Self.ElementType) -> RxSwift.Single<Self.ElementType>
  public static func just(_ element: Self.ElementType, scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.Single<Self.ElementType>
  public static func error(_ error: Swift.Error) -> RxSwift.Single<Self.ElementType>
  public static func never() -> RxSwift.Single<Self.ElementType>
}
extension RxSwift.PrimitiveSequenceType where Self.TraitType == RxSwift.SingleTrait {
  public func `do`(onSuccess: ((Self.ElementType) throws -> Swift.Void)? = nil, onError: ((Swift.Error) throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> RxSwift.Single<Self.ElementType>
  @available(*, deprecated, renamed: "do(onSuccess:onError:onSubscribe:onSubscribed:onDispose:)")
  public func `do`(onNext: ((Self.ElementType) throws -> Swift.Void)?, onError: ((Swift.Error) throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> RxSwift.Single<Self.ElementType>
  public func filter(_ predicate: @escaping (Self.ElementType) throws -> Swift.Bool) -> RxSwift.Maybe<Self.ElementType>
  public func map<R>(_ transform: @escaping (Self.ElementType) throws -> R) -> RxSwift.Single<R>
  public func flatMap<R>(_ selector: @escaping (Self.ElementType) throws -> RxSwift.Single<R>) -> RxSwift.Single<R>
  public func flatMapMaybe<R>(_ selector: @escaping (Self.ElementType) throws -> RxSwift.Maybe<R>) -> RxSwift.Maybe<R>
  public func flatMapCompletable(_ selector: @escaping (Self.ElementType) throws -> RxSwift.Completable) -> RxSwift.Completable
  public static func zip<C, R>(_ collection: C, _ resultSelector: @escaping ([Self.ElementType]) throws -> R) -> RxSwift.PrimitiveSequence<Self.TraitType, R> where C : Swift.Collection, C.Element == RxSwift.PrimitiveSequence<RxSwift.SingleTrait, Self.ElementType>
  public static func zip<C>(_ collection: C) -> RxSwift.PrimitiveSequence<Self.TraitType, [Self.ElementType]> where C : Swift.Collection, C.Element == RxSwift.PrimitiveSequence<RxSwift.SingleTrait, Self.ElementType>
  public func catchErrorJustReturn(_ element: Self.ElementType) -> RxSwift.PrimitiveSequence<Self.TraitType, Self.ElementType>
  public func asMaybe() -> RxSwift.Maybe<Self.ElementType>
  public func asCompletable() -> RxSwift.Completable
}
@_inheritsConvenienceInitializers final public class SingleAssignmentDisposable : RxSwift.DisposeBase, RxSwift.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public func setDisposable(_ disposable: RxSwift.Disposable)
  final public func dispose()
  @objc deinit
}
extension RxSwift.ObservableType {
  public func single() -> RxSwift.Observable<Self.E>
  public func single(_ predicate: @escaping (Self.E) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func skip(_ count: Swift.Int) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func skip(_ duration: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func skipUntil<O>(_ other: O) -> RxSwift.Observable<Self.E> where O : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public func skipWhile(_ predicate: @escaping (Self.E) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func startWith(_ elements: Self.E...) -> RxSwift.Observable<Self.E>
}
public protocol SubjectType : RxSwift.ObservableType {
  associatedtype SubjectObserverType : RxSwift.ObserverType
  func asObserver() -> Self.SubjectObserverType
}
extension RxSwift.ObservableType {
  public func subscribeOn(_ scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.Observable<Self.E>
}
public typealias RxAbstractInteger = Swift.FixedWidthInteger
extension RxSwift.ObservableType {
  public func flatMapLatest<O>(_ selector: @escaping (Self.E) throws -> O) -> RxSwift.Observable<O.E> where O : RxSwift.ObservableConvertibleType
}
extension RxSwift.ObservableType where Self.E : RxSwift.ObservableConvertibleType {
  public func switchLatest() -> RxSwift.Observable<Self.E.E>
}
extension RxSwift.ObservableType {
  public func ifEmpty(switchTo other: RxSwift.Observable<Self.E>) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func take(_ count: Swift.Int) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func take(_ duration: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func takeLast(_ count: Swift.Int) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func takeUntil<O>(_ other: O) -> RxSwift.Observable<Self.E> where O : RxSwift.ObservableType
  public func takeUntil(_ behavior: RxSwift.TakeUntilBehavior, predicate: @escaping (Self.E) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
}
public enum TakeUntilBehavior {
  case inclusive
  case exclusive
  public static func == (a: RxSwift.TakeUntilBehavior, b: RxSwift.TakeUntilBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RxSwift.ObservableType {
  public func takeWhile(_ predicate: @escaping (Self.E) throws -> Swift.Bool) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func throttle(_ dueTime: RxSwift.RxTimeInterval, latest: Swift.Bool = true, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func timeout(_ dueTime: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E>
  public func timeout<O>(_ dueTime: RxSwift.RxTimeInterval, other: O, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E> where O : RxSwift.ObservableConvertibleType, Self.E == O.E
}
extension RxSwift.ObservableType where Self.E : Swift.FixedWidthInteger {
  public static func interval(_ period: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType where Self.E : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: RxSwift.RxTimeInterval, period: RxSwift.RxTimeInterval? = nil, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Self.E>
}
extension RxSwift.ObservableType {
  public func toArray() -> RxSwift.Observable<[Self.E]>
}
extension RxSwift.ObservableType {
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, observableFactory: @escaping (Resource) throws -> RxSwift.Observable<Self.E>) -> RxSwift.Observable<Self.E> where Resource : RxSwift.Disposable
}
public protocol VirtualTimeConverterType {
  associatedtype VirtualTimeUnit
  associatedtype VirtualTimeIntervalUnit
  func convertFromVirtualTime(_ virtualTime: Self.VirtualTimeUnit) -> RxSwift.RxTime
  func convertToVirtualTime(_ time: RxSwift.RxTime) -> Self.VirtualTimeUnit
  func convertFromVirtualTimeInterval(_ virtualTimeInterval: Self.VirtualTimeIntervalUnit) -> RxSwift.RxTimeInterval
  func convertToVirtualTimeInterval(_ timeInterval: RxSwift.RxTimeInterval) -> Self.VirtualTimeIntervalUnit
  func offsetVirtualTime(_ time: Self.VirtualTimeUnit, offset: Self.VirtualTimeIntervalUnit) -> Self.VirtualTimeUnit
  func compareVirtualTime(_ lhs: Self.VirtualTimeUnit, _ rhs: Self.VirtualTimeUnit) -> RxSwift.VirtualTimeComparison
}
public enum VirtualTimeComparison {
  case lessThan
  case equal
  case greaterThan
  public static func == (a: RxSwift.VirtualTimeComparison, b: RxSwift.VirtualTimeComparison) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class VirtualTimeScheduler<Converter> : RxSwift.SchedulerType where Converter : RxSwift.VirtualTimeConverterType {
  public typealias VirtualTime = Converter.VirtualTimeUnit
  public typealias VirtualTimeInterval = Converter.VirtualTimeIntervalUnit
  public var now: RxSwift.RxTime {
    get
  }
  public var clock: RxSwift.VirtualTimeScheduler<Converter>.VirtualTime {
    get
  }
  public init(initialClock: RxSwift.VirtualTimeScheduler<Converter>.VirtualTime, converter: Converter)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  public func scheduleRelative<StateType>(_ state: StateType, dueTime: RxSwift.RxTimeInterval, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  public func scheduleRelativeVirtual<StateType>(_ state: StateType, dueTime: RxSwift.VirtualTimeScheduler<Converter>.VirtualTimeInterval, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  public func scheduleAbsoluteVirtual<StateType>(_ state: StateType, time: Converter.VirtualTimeUnit, action: @escaping (StateType) -> RxSwift.Disposable) -> RxSwift.Disposable
  open func adjustScheduledTime(_ time: Converter.VirtualTimeUnit) -> Converter.VirtualTimeUnit
  public func start()
  public func advanceTo(_ virtualTime: RxSwift.VirtualTimeScheduler<Converter>.VirtualTime)
  public func sleep(_ virtualInterval: RxSwift.VirtualTimeScheduler<Converter>.VirtualTimeInterval)
  public func stop()
  @objc deinit
}
extension RxSwift.VirtualTimeScheduler : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RxSwift.ObservableType {
  public func window(timeSpan: RxSwift.RxTimeInterval, count: Swift.Int, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<RxSwift.Observable<Self.E>>
}
extension RxSwift.ObservableType {
  public func withLatestFrom<SecondO, ResultType>(_ second: SecondO, resultSelector: @escaping (Self.E, SecondO.E) throws -> ResultType) -> RxSwift.Observable<ResultType> where SecondO : RxSwift.ObservableConvertibleType
  public func withLatestFrom<SecondO>(_ second: SecondO) -> RxSwift.Observable<SecondO.E> where SecondO : RxSwift.ObservableConvertibleType
}
extension RxSwift.ObservableType {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> RxSwift.Observable<(O1.E, O2.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> RxSwift.Observable<(O1.E, O2.E, O3.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E, O5.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType, O7 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType, O7 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> Self.E) -> RxSwift.Observable<Self.E> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType, O7 : RxSwift.ObservableType, O8 : RxSwift.ObservableType
}
extension RxSwift.ObservableType where Self.E == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> RxSwift.Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)> where O1 : RxSwift.ObservableType, O2 : RxSwift.ObservableType, O3 : RxSwift.ObservableType, O4 : RxSwift.ObservableType, O5 : RxSwift.ObservableType, O6 : RxSwift.ObservableType, O7 : RxSwift.ObservableType, O8 : RxSwift.ObservableType
}
extension RxSwift.ObservableType {
  public static func zip<C>(_ collection: C, _ resultSelector: @escaping ([C.Iterator.Element.E]) throws -> Self.E) -> RxSwift.Observable<Self.E> where C : Swift.Collection, C.Element : RxSwift.ObservableType
  public static func zip<C>(_ collection: C) -> RxSwift.Observable<[Self.E]> where C : Swift.Collection, Self.E == C.Element.E, C.Element : RxSwift.ObservableType
}
extension RxSwift.SubjectLifetimeScope : Swift.Equatable {}
extension RxSwift.SubjectLifetimeScope : Swift.Hashable {}
extension RxSwift.TakeUntilBehavior : Swift.Equatable {}
extension RxSwift.TakeUntilBehavior : Swift.Hashable {}
extension RxSwift.VirtualTimeComparison : Swift.Equatable {}
extension RxSwift.VirtualTimeComparison : Swift.Hashable {}
